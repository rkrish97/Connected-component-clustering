# Connected-component-clustering
### 1. Mounting the Google Drive

The first cell in the program was used to mount the google drive. It was important to mount your google drive which has the image which can then be used to run the remaining parts of the code. Once you run the cell, the output box displays a link. When you click on the link, it prompts you to log in to your google account. Once you do that, a link appears which then has to be pasted in the textbox in the output area. Once you get the following message, **"Mounted at /content/gdrive"**, the drive has successfully been mounted. 

\\
### 2. Importing Libraries and the Input Image
The libraries mentioned in the second cell are required to run the program. The cv2 library was used for reading the images. Numpy module was required to run all the matrix and array operations efficiently. Since images are basically matrices, NumPy was really handy for this purpose. The 'time' module was required to calculate how long the program takes to finish running on an input image. This was required to calculate how fast and efficient the clustering algorithm was. A higher run-time translates to increased complexity and decreased efficiency. The location of the image in the google drive has to be provided in the 'path' variable. The input image was then displayed in the same cell.

\\
### 3. Connected Component Clustering 
The input image was first thresholded by taking all other pixel values other than 255 to be 0. This was done so as to obtain a binary image that can then be operated upon. The image was then padded with zeros on all four sides so that it becomes easy to access all the neighboring pixels for each pixel in the image. A matrix 'mat' was created to be having all zeros and having the same size as the input image. This matrix will store which cluster each pixel belongs to. Two other arrays, 'equal_max' and 'equal_min' were used to resolve conflicts which will be explained later.

\
The program iteratively runs through each pixel and finds out whether the pixel is white or not. The algorithm acts on the pixel only if it is white (intensity = 255). This is done to reduce the complexity of the program by not checking for all conditions on each pixel of the image which includes a lot of black pixels as well. Operating on these black pixels is a waste of resources because the task is to cluster only the white pixels.

\
The component clustering algorithm looks for all 8 pixels which are connected to any pixel and groups them together. After running the program after considering all the 8 pixels surrounding a pixel, it was found out that it wasn't necessary to look at all 8 pixels connected to a pixel. It is just enough to look at the top 3 pixels and the one to the left of the current pixels. This is because the program iteratively moves through the pixels along the right-hand side and eventually moves towards the bottom. So it is enough to consider only the above-mentioned pixels and this helps in reducing the complexity of the program and thereby increasing efficiency.

\
The program looks at the 4 pixels connected to the current pixel and checks whether the neighbors have been classified into a cluster. When it finds out that it doesn't have neighbors belonging to a cluster, the program assigns a new cluster number for the current pixel. But whenever the neighbors have a cluster number assigned to them, it assigns the same number for the current pixel as well.

\
The problem with this method is that whenever there are two neighbors having different cluster numbers assigned to them, a conflict is created as to which cluster number should be assigned for the current pixel. So this requires a few more passes into the image to resolve such conflicts. The conflict can be resolved by assigning the minimum value from the two cluster numbers and assign it for the current pixel. Then, the maximum and the minimum value among the two are stored in separate arrays for conflict resolution during subsequent passes through the image. When assigning the maximum and minimum values, it is checked whether the minimum element is already present in the list of maximum values. This is done so as to avoid an extra step while mapping from one maximum value to a minimum value. For example, if there are two conflicts, 2->1 and 3->2, the conflict from 3->2 should logically map to 1 by cutting an extra step of mapping it to 2 and then mapping the 2 to 1. But it is important to find the first instance of the minimum element in the maximum array for this to work and it is not always possible to do that because of the way in which the iteration through the matrix takes place. This feature was still kept in the algorithm so that it can reduce the complexity as much as possible. After running iteratively through each pixel and performing the mentioned steps, each white pixel was assigned to a cluster with/without conflict.

\
A conflict while assigning the cluster number means that the two clusters having conflict belong to the same object and not two different objects. Based on this understanding, all the values in the cluster matrix having the maximum values from the equal_max array were replaced by the corresponding entries in the minimum array. But this has to be done starting from the largest cluster number going through the smallest. For this reason, the two arrays were flipped and then the replacement was iteratively done for each entry in the equal_max list belonging to 'mat'. the program initially finds the number of unique elements in the matrix after the first pass and then runs the replacement step that many times. This is required so that all the replacements are done perfectly and there is no replacement that was left undone. Even when the list gets flipped, it does not mean that the list has the cluster number in the descending order. When the program moves through all the columns of a row and records the conflict, after moving to another row, the program might encounter a lower cluster and append it to the arrays. The complexity of running the replacement a couple more times and the complexity of sorting the entries in descending order while maintaining the same relating between the arrays are similar. By taking it into consideration, the loop was run a couple more times.
The number of unique values excluding one (black pixels) gives the number of clusters in the image. 255 was divided by the number of clusters in order to increase the intensity of each cluster's pixel by the same amount. The time taken to run the ccGroup function was calculated and displayed along with the number of clusters and the output image with different grayscales as well.
